<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>SLAP-GAP</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />

<!-- PWA manifest -->
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#2a9df4">

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
body { margin:0; padding:0; font-family:Arial, sans-serif; }
#map { position:absolute; top:0; bottom:0; left:0; right:320px; }
#sidebar { position:absolute; right:0; top:0; bottom:0; width:320px; padding:12px; background:#f7f7f7; overflow:auto; border-left:1px solid #ccc; }
.btn { display:inline-block; padding:6px 10px; margin:3px 2px; background:#2a9df4; color:white; border-radius:4px; text-decoration:none; cursor:pointer; font-size:13px; border:none; }
.btn.small { padding:3px 6px; font-size:12px; }
input[type=text], input[type=number], input[type=password], textarea, select { width:100%; box-sizing:border-box; padding:6px; margin:3px 0; }
.coord-input-group { display:flex; gap:5px; margin:3px 0; }
.coord-input-group input { flex:1; }
.coord-input-group label { font-size:11px; color:#666; }
.waypoint-item { border-bottom:1px dashed #ccc; padding:4px; margin-bottom:4px; }
.area-item { border-bottom:1px dashed #ccc; padding:4px; margin-bottom:4px; background:#f0f0ff; }
.waypoint-actions { margin-top:4px; }
.small { font-size:12px; color:#666; }
#speedInput { width:60px; display:inline-block; }
#routeSummary { font-size:12px; margin-top:6px; }
#gpsInfo { font-size:13px; margin-top:8px; padding:8px; background:#e8f4f8; border-radius:4px; border-left:3px solid #2a9df4; }
#gpsInfo .gps-label { font-weight:bold; color:#2a9df4; }
#gpsInfo .gps-value { color:#333; }
#credit { font-size:12px; font-weight:bold; color:#333; margin-top:12px; text-align:center; }

/* Measurement Tool Info Box */
#measurementInfo {
  position: absolute;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.9);
  color: white;
  padding: 15px 25px;
  border-radius: 10px;
  font-size: 15px;
  z-index: 3000;
  display: none;
  box-shadow: 0 4px 20px rgba(0,0,0,0.5);
  pointer-events: none;
  min-width: 280px;
}
#measurementInfo .measure-label { 
  font-weight: bold; 
  color: #ffd700;
  display: inline-block;
  width: 120px;
}
#measurementInfo .measure-value {
  color: #fff;
  font-family: monospace;
  font-size: 16px;
}
#measurementInfo div {
  margin: 5px 0;
}

#measureBtn {
  position: absolute;
  top: 80px;
  left: 10px;
  z-index: 1000;
  background: #ff00ff;
  padding: 10px 15px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

#stopMeasureBtn {
  position: absolute;
  top: 130px;
  left: 10px;
  z-index: 1000;
  background: #dc3545;
  padding: 10px 15px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  display: none;
}

/* Small screens */
@media (max-width:1024px) {
  #map { right:0; bottom:45%; }
  #sidebar { position:fixed; left:0; right:0; bottom:0; top:auto; height:45%; width:auto; border-left:none; border-top:1px solid #ccc; }
}

/* Password Screen */
#passwordScreen {
  position:fixed; left:0; top:0; right:0; bottom:0; background:linear-gradient(135deg, #2a9df4 0%, #1e5a8e 100%);
  z-index:99999; display:flex; align-items:center; justify-content:center; color:#fff;
}
#passwordScreen .password-box {
  background:#fff; padding:40px; border-radius:12px; box-shadow:0 8px 32px rgba(0,0,0,0.3);
  max-width:400px; width:90%; text-align:center; color:#333;
}
#passwordScreen h2 { margin-top:0; color:#2a9df4; }
#passwordScreen input[type=password] {
  font-size:16px; padding:12px; margin:20px 0; border:2px solid #ddd; border-radius:6px;
}
#passwordScreen .btn { padding:12px 30px; font-size:16px; margin-top:10px; }
#passwordScreen .error { color:#dc3545; margin-top:10px; display:none; }
#passwordScreen .info { font-size:14px; color:#666; margin-top:15px; }

/* Insecure Overlay */
#insecureOverlay {
  position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.6);
  z-index:9999; display:none; color:#fff; padding:20px; box-sizing:border-box;
}
#insecureOverlay .box { background:#222; padding:16px; border-radius:8px; max-width:720px; margin:auto; }
#insecureOverlay a { color:#ffd; text-decoration:underline; }

/* Modal for area creation */
#areaModal {
  position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.7);
  z-index:10000; display:none; color:#333; padding:20px; box-sizing:border-box; overflow:auto;
}
#areaModal .modal-content { background:#fff; padding:20px; border-radius:8px; max-width:500px; margin:auto; }
#areaModal input, #areaModal textarea { margin-bottom:10px; }
#cornerInputs { margin:10px 0; }
.corner-input { margin-bottom:8px; }

/* Color selector for areas */
.color-selector {
  display: flex;
  gap: 10px;
  margin: 10px 0;
  flex-wrap: wrap;
}
.color-option {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 3px solid #ddd;
  cursor: pointer;
  transition: all 0.2s;
}
.color-option:hover {
  transform: scale(1.1);
}
.color-option.selected {
  border-color: #000;
  border-width: 4px;
  box-shadow: 0 0 10px rgba(0,0,0,0.3);
}

/* Marker type selector */
.marker-type-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin: 10px 0;
}
.marker-type-option {
  border: 2px solid #ddd;
  padding: 8px;
  text-align: center;
  cursor: pointer;
  border-radius: 6px;
  transition: all 0.2s;
}
.marker-type-option:hover {
  background: #f0f0f0;
}
.marker-type-option.selected {
  border-color: #2a9df4;
  background: #e8f4f8;
}
.marker-icon-preview {
  font-size: 20px;
  margin-bottom: 4px;
}
.marker-type-label {
  font-size: 11px;
  color: #666;
}

/* Custom SVG marker styles */
.custom-marker {
  background: transparent;
  border: none;
}

/* Info display styles */
.info-text {
  font-size: 11px;
  color: #666;
  font-style: italic;
  margin-top: 2px;
}
</style>
</head>
<body>

<!-- PASSWORD SCREEN -->
<div id="passwordScreen">
  <div class="password-box">
    <h2>üîí Secure Access</h2>
    <p>Enter password to access Air Navigation</p>
    <input type="password" id="passwordInput" placeholder="Enter password" />
    <br>
    <button class="btn" id="passwordSubmit">Unlock</button>
    <div class="error" id="passwordError">‚ùå Incorrect password. Please try again.</div>
    <div class="info">Password will be remembered on this browser</div>
  </div>
</div>

<!-- MEASUREMENT INFO DISPLAY -->
<div id="measurementInfo">
  <div><span class="measure-label">Distance:</span> <span class="measure-value" id="measureDist">--</span></div>
  <div><span class="measure-label">Bearing A‚ÜíB:</span> <span class="measure-value" id="measureBrgAB">--</span></div>
  <div><span class="measure-label">Bearing B‚ÜíA:</span> <span class="measure-value" id="measureBrgBA">--</span></div>
</div>

<!-- MAP -->
<div id="map">
  <button id="measureBtn" class="btn">üìè Measure</button>
  <button id="stopMeasureBtn" class="btn">‚èπ Stop Measure</button>
</div>

<!-- SIDEBAR -->
<div id="sidebar">
  <h3>Waypoint Tool</h3>
  <small class="small">Click map to add waypoint. Use Measure button for distance/bearing scale.</small>

  <label>Jump to coordinates:</label>
  <div style="margin-bottom:8px;">
    <div class="coord-input-group">
      <div style="flex:1;">
        <label>Lat Deg</label>
        <input id="latDeg" type="number" placeholder="23" />
      </div>
      <div style="flex:1;">
        <label>Lat Min</label>
        <input id="latMin" type="number" step="0.001" placeholder="41.100" />
      </div>
      <div style="flex:0.5;">
        <label>N/S</label>
        <select id="latDir">
          <option value="N">N</option>
          <option value="S">S</option>
        </select>
      </div>
    </div>
    <div class="coord-input-group">
      <div style="flex:1;">
        <label>Lon Deg</label>
        <input id="lonDeg" type="number" placeholder="90" />
      </div>
      <div style="flex:1;">
        <label>Lon Min</label>
        <input id="lonMin" type="number" step="0.001" placeholder="21.378" />
      </div>
      <div style="flex:0.5;">
        <label>E/W</label>
        <select id="lonDir">
          <option value="E">E</option>
          <option value="W">W</option>
        </select>
      </div>
    </div>
  </div>
  <a id="goBtn" class="btn">Go/Add</a>

  <h4>Waypoints</h4>
  <div id="list"></div>

  <div>
    <label>Speed (knots for ETA):</label>
    <input id="speedInput" placeholder="kn" type="text"/>
  </div>
  <div style="margin-top:6px;">
    <a id="routeBtn" class="btn">Route selected</a>
    <a id="clearRouteBtn" class="btn" style="background:#999">Clear route</a>
  </div>

  <h4>Flying / Direct-To Modes</h4>
  <a id="startFlyBtn" class="btn">Start Flying Mode</a>
  <a id="stopFlyBtn" class="btn" style="background:#dc3545">Stop Flying Mode</a>
  <a id="startDirectBtn" class="btn" style="background:#6f42c1">Start Direct-To</a>
  <a id="stopDirectBtn" class="btn" style="background:#dc3545">Stop Direct-To</a>
  <a id="recenterBtn" class="btn" style="background:#28a745">Re-center Map</a>

  <h4>Moving Track (Flying Mode Only)</h4>
  <a id="movingTrackOnBtn" class="btn" style="background:#00c853">Moving Track ON</a>
  <a id="movingTrackOffBtn" class="btn" style="background:#ff5722">Moving Track OFF</a>

  <h4>Direct-To Waypoint</h4>
  <select id="directSelect"><option value="">Select Waypoint</option></select>

  <h4>Area Management</h4>
  <a id="createAreaBtn" class="btn" style="background:#8b45c1">Create Area</a>
  <label>Edit Area:</label>
  <select id="editAreaSelect"><option value="">Select Area to Edit</option></select>
  <a id="editAreaBtn" class="btn" style="background:#ff8c00">Edit Selected</a>
  <label>Delete Area:</label>
  <select id="deleteAreaSelect"><option value="">Select Area to Delete</option></select>
  <a id="deleteAreaBtn" class="btn" style="background:#dc3545">Delete Selected</a>

  <h4>Areas List</h4>
  <div id="areaList"></div>

  <h4>Import/Export</h4>
  <a id="saveBtn" class="btn" style="background:#28a745">Save</a>
  <a id="exportBtn" class="btn" style="background:#6c757d">Export JSON</a>
  <a id="importBtn" class="btn" style="background:#ffc107">Import</a>
  <textarea id="jsonArea" rows="4" placeholder="Paste JSON here"></textarea>

  <h4>Coords:</h4>
  <div id="coordsOut" class="small">None</div>
  
  <div id="gpsInfo" style="display:none;">
    <div><span class="gps-label">GPS Speed:</span> <span class="gps-value" id="gpsSpeed">-- kts</span></div>
    <div><span class="gps-label">Course Over Ground:</span> <span class="gps-value" id="gpsCourse">--¬∞</span></div>
  </div>
  
  <div id="routeSummary" class="small"></div>

  <div id="credit">SLAP_GAP, MADE BY LT CDR SADMAN, P NO 3223</div>
</div>

<!-- Area Creation Modal -->
<div id="areaModal">
  <div class="modal-content">
    <h3 id="modalTitle">Create New Area</h3>
    <label>Number of corners:</label>
    <input type="number" id="numCorners" min="3" placeholder="e.g., 4" />
    <a id="setCornerBtn" class="btn">Set Corners</a>
    
    <div id="cornerInputs"></div>
    
    <div id="nameSection" style="display:none;">
      <label>Area Name:</label>
      <input type="text" id="areaName" placeholder="Enter area name" />
      
      <label>Area Color:</label>
      <div class="color-selector">
        <div class="color-option selected" data-color="#dc3545" style="background:#dc3545;" title="Red"></div>
        <div class="color-option" data-color="#0d6efd" style="background:#0d6efd;" title="Blue"></div>
        <div class="color-option" data-color="#8b45c1" style="background:#8b45c1;" title="Purple"></div>
        <div class="color-option" data-color="#ffc107" style="background:#ffc107;" title="Yellow"></div>
      </div>
      
      <label>Area Info/Notes:</label>
      <textarea id="areaInfo" rows="3" placeholder="Enter information about this area..."></textarea>
      
      <a id="saveAreaBtn" class="btn" style="background:#28a745">Save Area</a>
      <a id="cancelAreaBtn" class="btn" style="background:#dc3545">Cancel</a>
    </div>
  </div>
</div>

<!-- Insecure context overlay -->
<div id="insecureOverlay" aria-hidden="true">
  <div class="box">
    <h2>Security / Location Notice</h2>
    <p>This page requires secure origin (HTTPS or localhost) for the device's GPS to work properly.</p>
    <p><b>Recommended:</b> Use your GitHub Pages HTTPS link.</p>
    <p><a id="hideOverlay" class="btn small" style="background:#28a745">I understand - continue anyway</a></p>
  </div>
</div>

<!-- Leaflet -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
/* ========== PASSWORD PROTECTION ========== */
const CORRECT_PASSWORD = 'Lilymaafroz245';
const PASSWORD_KEY = 'air_nav_authenticated';

function checkAuthentication(){
  const isAuthenticated = localStorage.getItem(PASSWORD_KEY);
  if(isAuthenticated === 'true'){
    document.getElementById('passwordScreen').style.display = 'none';
    initializeApp();
  } else {
    document.getElementById('passwordScreen').style.display = 'flex';
  }
}

document.getElementById('passwordSubmit').onclick = function(){
  const enteredPassword = document.getElementById('passwordInput').value;
  if(enteredPassword === CORRECT_PASSWORD){
    localStorage.setItem(PASSWORD_KEY, 'true');
    document.getElementById('passwordScreen').style.display = 'none';
    document.getElementById('passwordError').style.display = 'none';
    initializeApp();
  } else {
    document.getElementById('passwordError').style.display = 'block';
    document.getElementById('passwordInput').value = '';
    document.getElementById('passwordInput').focus();
  }
};

document.getElementById('passwordInput').addEventListener('keypress', function(e){
  if(e.key === 'Enter'){
    document.getElementById('passwordSubmit').click();
  }
});

/* ========== COORDINATE CONVERSION FUNCTIONS ========== */
function decimalToDMS(decimal, isLat) {
  const absolute = Math.abs(decimal);
  const degrees = Math.floor(absolute);
  const minutes = (absolute - degrees) * 60;
  const direction = isLat ? (decimal >= 0 ? 'N' : 'S') : (decimal >= 0 ? 'E' : 'W');
  return { degrees, minutes, direction };
}

function DMSToDecimal(degrees, minutes, direction) {
  let decimal = parseFloat(degrees) + parseFloat(minutes) / 60;
  if (direction === 'S' || direction === 'W') {
    decimal = -decimal;
  }
  return decimal;
}

function formatDMS(decimal, isLat) {
  const dms = decimalToDMS(decimal, isLat);
  return `${dms.degrees}¬∞ ${dms.minutes.toFixed(3)}' ${dms.direction}`;
}

/* ========== MARKER TYPES ========== */
const MARKER_TYPES = {
  default: { color: '#ff0000', shape: 'circle', label: 'Default' },
  helipad: { color: '#000080', shape: 'H', label: 'Helipad' },
  star: { color: '#FFD700', shape: 'star', label: 'Important' },
  diamond: { color: '#C0C0C0', shape: 'diamond', label: 'Checkpoint' },
  triangle: { color: '#FFFFFF', shape: 'triangle', label: 'Marker' },
  airport: { color: '#00ff00', shape: 'square', label: 'Airport' }
};

function createMarkerIcon(type = 'default') {
  const markerType = MARKER_TYPES[type] || MARKER_TYPES.default;
  
  if (markerType.shape === 'circle') {
    return L.circleMarker([0, 0], {
      radius: 5,
      color: markerType.color,
      fillColor: markerType.color,
      fillOpacity: 0.9,
      weight: 2
    });
  }
  
  let svgIcon = '';
  const color = markerType.color;
  
  switch(markerType.shape) {
    case 'H':
      svgIcon = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
        <rect x="2" y="2" width="16" height="16" fill="${color}" stroke="#000" stroke-width="1.5"/>
        <text x="10" y="14" font-size="12" font-weight="bold" text-anchor="middle" fill="#FFFFFF">H</text>
      </svg>`;
      break;
    case 'star':
      svgIcon = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
        <polygon points="10,2 12,8 18,8 13,12 15,18 10,14 5,18 7,12 2,8 8,8" 
                 fill="${color}" stroke="#000" stroke-width="1"/>
      </svg>`;
      break;
    case 'diamond':
      svgIcon = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
        <polygon points="10,2 18,10 10,18 2,10" fill="${color}" stroke="#000" stroke-width="1.5"/>
      </svg>`;
      break;
    case 'triangle':
      svgIcon = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
        <polygon points="10,2 18,17 2,17" fill="${color}" stroke="#000" stroke-width="1.5"/>
      </svg>`;
      break;
    case 'square':
      svgIcon = `<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
        <rect x="3" y="3" width="14" height="14" fill="${color}" stroke="#000" stroke-width="1.5"/>
      </svg>`;
      break;
  }
  
  return L.divIcon({
    html: svgIcon,
    className: 'custom-marker',
    iconSize: [20, 20],
    iconAnchor: [10, 10]
  });
}

/* ========== CORE MAP APP ========== */
function initializeApp(){

// --- Secure context hint ---
const insecureOverlay = document.getElementById('insecureOverlay');
function checkSecureContextAndWarn(){
  const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  const ok = (location.protocol === 'https:' || isLocalhost);
  if(!ok){
    insecureOverlay.style.display = 'block';
    insecureOverlay.setAttribute('aria-hidden','false');
  }
}
document.getElementById('hideOverlay').onclick = ()=>{
  insecureOverlay.style.display = 'none';
  insecureOverlay.setAttribute('aria-hidden','true');
};
checkSecureContextAndWarn();

// --- Leaflet map ---
const map = L.map('map', {
  zoomControl: true,
  dragging: true,
  touchZoom: true,
  doubleClickZoom: true,
  scrollWheelZoom: true
}).setView([23.685, 90.3563], 7);

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 18,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

// --- State ---
let waypoints = [];
let markers = {};
let selected = [];
let routeLayer = null;
let checkpointMarkers = [];
let flyMarker = null;
let flyWatchId = null;
let directLayer = null;
let directTargetId = null;
let lastSpeedGPS = 0;
let lastCourseGPS = 0;

// --- AREA STATE ---
let areas = [];
let areaPolygons = {};
let editingAreaId = null;

// --- MEASUREMENT TOOL STATE ---
let measurementLine = null;
let measureStartMarker = null;
let measureEndMarker = null;
let measureActive = false;

// --- MOVING TRACK STATE ---
let movingTrackLine = null;
let movingTrackActive = false;
let movingTrackUpdateInterval = null;

// --- DOM ---
const listDiv = document.getElementById('list');
const coordsOut = document.getElementById('coordsOut');
const routeSummaryDiv = document.getElementById('routeSummary');
const directSelect = document.getElementById('directSelect');
const recenterBtn = document.getElementById('recenterBtn');
const areaListDiv = document.getElementById('areaList');
const editAreaSelect = document.getElementById('editAreaSelect');
const deleteAreaSelect = document.getElementById('deleteAreaSelect');
const gpsInfoDiv = document.getElementById('gpsInfo');
const gpsSpeedSpan = document.getElementById('gpsSpeed');
const gpsCourseSpan = document.getElementById('gpsCourse');
const measurementInfoDiv = document.getElementById('measurementInfo');
const measureBtn = document.getElementById('measureBtn');
const stopMeasureBtn = document.getElementById('stopMeasureBtn');
const movingTrackOnBtn = document.getElementById('movingTrackOnBtn');
const movingTrackOffBtn = document.getElementById('movingTrackOffBtn');

// --- Utils ---
function haversineNM(lat1,lon1,lat2,lon2){
  const R=6371e3, toRad=v=>v*Math.PI/180;
  const œÜ1=toRad(lat1),œÜ2=toRad(lat2),ŒîœÜ=toRad(lat2-lat1),ŒîŒª=toRad(lon2-lon1);
  const a=Math.sin(ŒîœÜ/2)**2+Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))/1852;
}
function bearing(lat1,lon1,lat2,lon2){
  const toRad=v=>v*Math.PI/180,toDeg=v=>v*180/Math.PI;
  const œÜ1=toRad(lat1),œÜ2=toRad(lat2),Œª1=toRad(lon1),Œª2=toRad(lon2);
  const y=Math.sin(Œª2-Œª1)*Math.cos(œÜ2);
  const x=Math.cos(œÜ1)*Math.sin(œÜ2)-Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(Œª2-Œª1);
  return (toDeg(Math.atan2(y,x))+360)%360;
}

// Calculate destination point given start point, bearing, and distance
function destinationPoint(lat, lon, bearing, distanceNM) {
  const R = 6371e3; // Earth radius in meters
  const distanceM = distanceNM * 1852; // Convert NM to meters
  const toRad = v => v * Math.PI / 180;
  const toDeg = v => v * 180 / Math.PI;
  
  const œÜ1 = toRad(lat);
  const Œª1 = toRad(lon);
  const brng = toRad(bearing);
  const Œ¥ = distanceM / R;
  
  const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(Œ¥) + Math.cos(œÜ1) * Math.sin(Œ¥) * Math.cos(brng));
  const Œª2 = Œª1 + Math.atan2(Math.sin(brng) * Math.sin(Œ¥) * Math.cos(œÜ1), Math.cos(Œ¥) - Math.sin(œÜ1) * Math.sin(œÜ2));
  
  return {
    lat: toDeg(œÜ2),
    lon: toDeg(Œª2)
  };
}

// --- Update GPS Info Display ---
function updateGPSInfo(speed, heading){
  lastSpeedGPS = speed;
  lastCourseGPS = heading;
  gpsSpeedSpan.textContent = speed.toFixed(1) + ' kts';
  gpsCourseSpan.textContent = heading.toFixed(1) + '¬∞';
}

// --- MOVING TRACK FUNCTIONS ---
function startMovingTrack() {
  if (!flyMarker) {
    alert('Moving Track only works in Flying Mode. Please start Flying Mode first.');
    return;
  }
  
  movingTrackActive = true;
  updateMovingTrack();
  
  // Update moving track every second
  movingTrackUpdateInterval = setInterval(updateMovingTrack, 1000);
  
  console.log('Moving Track activated');
}

function stopMovingTrack() {
  movingTrackActive = false;
  
  if (movingTrackUpdateInterval) {
    clearInterval(movingTrackUpdateInterval);
    movingTrackUpdateInterval = null;
  }
  
  if (movingTrackLine) {
    map.removeLayer(movingTrackLine);
    movingTrackLine = null;
  }
  
  console.log('Moving Track deactivated');
}

function updateMovingTrack() {
  if (!movingTrackActive || !flyMarker) {
    return;
  }
  
  const currentPos = flyMarker.getLatLng();
  const currentSpeed = lastSpeedGPS; // in knots
  const currentCourse = lastCourseGPS; // in degrees
  
  // Calculate distance that will be traveled in 20 minutes
  const timeMinutes = 20;
  const distanceNM = (currentSpeed * timeMinutes) / 60;
  
  // Calculate end point
  const endPoint = destinationPoint(currentPos.lat, currentPos.lng, currentCourse, distanceNM);
  
  // Remove old track line
  if (movingTrackLine) {
    map.removeLayer(movingTrackLine);
  }
  
  // Draw new track line
  movingTrackLine = L.polyline(
    [[currentPos.lat, currentPos.lng], [endPoint.lat, endPoint.lon]], 
    {
      color: '#00ff00',
      weight: 3,
      opacity: 0.8,
      dashArray: '10, 10',
      interactive: false
    }
  ).addTo(map);
  
  // Add tooltip showing the projected distance
  movingTrackLine.bindTooltip(
    `20-min track: ${distanceNM.toFixed(2)} NM @ ${currentCourse.toFixed(0)}¬∞`,
    { permanent: true, direction: 'center', className: 'track-tooltip' }
  );
}

// --- MEASUREMENT TOOL FUNCTIONS ---
function startMeasureTool() {
  measureActive = true;
  measureBtn.style.display = 'none';
  stopMeasureBtn.style.display = 'block';
  
  // Set initial measurement line across center of map
  const center = map.getCenter();
  const bounds = map.getBounds();
  const latSpan = (bounds.getNorth() - bounds.getSouth()) * 0.2;
  const lonSpan = (bounds.getEast() - bounds.getWest()) * 0.2;
  
  const startPoint = L.latLng(center.lat - latSpan, center.lng - lonSpan);
  const endPoint = L.latLng(center.lat + latSpan, center.lng + lonSpan);
  
  // Create thick measurement line
  measurementLine = L.polyline([startPoint, endPoint], {
    color: '#ff00ff',
    weight: 8,
    opacity: 0.8,
    interactive: false
  }).addTo(map);
  
  // Create BIG visible draggable endpoint markers with TRANSPARENT center
  const createBigEndpointIcon = () => {
    return L.divIcon({
      html: '<div style="width:40px;height:40px;background:transparent;border:5px solid #ff00ff;border-radius:50%;box-shadow:0 3px 10px rgba(0,0,0,0.5);"></div>',
      className: '',
      iconSize: [40, 40],
      iconAnchor: [20, 20]
    });
  };
  
  measureStartMarker = L.marker(startPoint, {
    icon: createBigEndpointIcon(),
    draggable: true,
    zIndexOffset: 3000
  }).addTo(map);
  
  measureEndMarker = L.marker(endPoint, {
    icon: createBigEndpointIcon(),
    draggable: true,
    zIndexOffset: 3000
  }).addTo(map);
  
  // Update line when markers are dragged
  measureStartMarker.on('drag', function() {
    const start = measureStartMarker.getLatLng();
    const end = measureEndMarker.getLatLng();
    measurementLine.setLatLngs([start, end]);
    updateMeasurementDisplay();
  });
  
  measureEndMarker.on('drag', function() {
    const start = measureStartMarker.getLatLng();
    const end = measureEndMarker.getLatLng();
    measurementLine.setLatLngs([start, end]);
    updateMeasurementDisplay();
  });
  
  updateMeasurementDisplay();
  measurementInfoDiv.style.display = 'block';
  
  console.log('Measurement tool started - markers created');
}

function stopMeasureTool() {
  measureActive = false;
  measureBtn.style.display = 'block';
  stopMeasureBtn.style.display = 'none';
  measurementInfoDiv.style.display = 'none';
  
  // Remove measurement line and markers
  if (measurementLine) {
    map.removeLayer(measurementLine);
    measurementLine = null;
  }
  if (measureStartMarker) {
    map.removeLayer(measureStartMarker);
    measureStartMarker = null;
  }
  if (measureEndMarker) {
    map.removeLayer(measureEndMarker);
    measureEndMarker = null;
  }
  
  console.log('Measurement tool stopped');
}

function updateMeasurementDisplay() {
  if (!measureStartMarker || !measureEndMarker) return;
  
  const startPoint = measureStartMarker.getLatLng();
  const endPoint = measureEndMarker.getLatLng();
  
  const dist = haversineNM(startPoint.lat, startPoint.lng, endPoint.lat, endPoint.lng);
  const brgAB = bearing(startPoint.lat, startPoint.lng, endPoint.lat, endPoint.lng);
  const brgBA = bearing(endPoint.lat, endPoint.lng, startPoint.lat, startPoint.lng);
  
  document.getElementById('measureDist').textContent = dist.toFixed(2) + ' NM';
  document.getElementById('measureBrgAB').textContent = brgAB.toFixed(1) + '¬∞';
  document.getElementById('measureBrgBA').textContent = brgBA.toFixed(1) + '¬∞';
}

// Measure button handlers
measureBtn.onclick = function(e) {
  e.stopPropagation();
  startMeasureTool();
};

stopMeasureBtn.onclick = function(e) {
  e.stopPropagation();
  stopMeasureTool();
};

// Moving Track button handlers
movingTrackOnBtn.onclick = function(e) {
  e.stopPropagation();
  startMovingTrack();
};

movingTrackOffBtn.onclick = function(e) {
  e.stopPropagation();
  stopMovingTrack();
};

// Click to add waypoint (only when not measuring)
map.on('click', e => {
  if (!measureActive) {
    coordsOut.textContent = formatDMS(e.latlng.lat, true) + ', ' + formatDMS(e.latlng.lng, false);
    addWaypoint(e.latlng.lat, e.latlng.lng);
  }
});

// --- Waypoints ---
function renderList(){
  listDiv.innerHTML='';
  directSelect.innerHTML='<option value="">Select Waypoint</option>';
  waypoints.forEach(w=>{
    const markerType = MARKER_TYPES[w.markerType || 'default'];
    const div=document.createElement('div');
    div.className='waypoint-item';
    div.innerHTML=`
      <b>${w.name}</b> <span style="font-size:10px; color:${markerType.color};">‚óè</span><br>
      <span class="small">${formatDMS(w.lat, true)}, ${formatDMS(w.lon, false)} - ${markerType.label}</span>
      ${w.info ? `<div class="info-text">${w.info}</div>` : ''}
      <div class="waypoint-actions">
        <a class="btn small" onclick="editWaypoint(${w.id})">‚úèÔ∏è</a>
        <a class="btn small" style="background:#dc3545" onclick="deleteWaypoint(${w.id})">üóëÔ∏è</a>
        <a class="btn small" style="background:#6f42c1" onclick="selectWaypoint(${w.id})">üéØ</a>
      </div>
    `;
    listDiv.appendChild(div);
    const opt=document.createElement('option');
    opt.value=w.id; opt.text=w.name; directSelect.appendChild(opt);
  });
}

window.editWaypoint = function(id){
  const wp=waypoints.find(w=>w.id===id);
  if(!wp)return;
  
  const latDMS = decimalToDMS(wp.lat, true);
  const lonDMS = decimalToDMS(wp.lon, false);
  
  const editModal = document.createElement('div');
  editModal.style.cssText = 'position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,0,0,0.7); z-index:10001; display:flex; align-items:center; justify-content:center; overflow:auto;';
  editModal.innerHTML = `
    <div style="background:#fff; padding:20px; border-radius:8px; max-width:400px; width:90%; max-height:90vh; overflow:auto;">
      <h3>Edit Waypoint</h3>
      <label>Name:</label>
      <input type="text" id="editName" value="${wp.name}" style="width:100%; padding:6px; margin:5px 0;">
      
      <label>Latitude:</label>
      <div style="display:flex; gap:5px; margin:5px 0;">
        <input type="number" id="editLatDeg" placeholder="Deg" value="${latDMS.degrees}" style="flex:1; padding:6px;">
        <input type="number" step="0.001" id="editLatMin" placeholder="Min" value="${latDMS.minutes.toFixed(3)}" style="flex:1; padding:6px;">
        <select id="editLatDir" style="flex:0.5; padding:6px;">
          <option value="N" ${latDMS.direction==='N'?'selected':''}>N</option>
          <option value="S" ${latDMS.direction==='S'?'selected':''}>S</option>
        </select>
      </div>
      
      <label>Longitude:</label>
      <div style="display:flex; gap:5px; margin:5px 0;">
        <input type="number" id="editLonDeg" placeholder="Deg" value="${lonDMS.degrees}" style="flex:1; padding:6px;">
        <input type="number" step="0.001" id="editLonMin" placeholder="Min" value="${lonDMS.minutes.toFixed(3)}" style="flex:1; padding:6px;">
        <select id="editLonDir" style="flex:0.5; padding:6px;">
          <option value="E" ${lonDMS.direction==='E'?'selected':''}>E</option>
          <option value="W" ${lonDMS.direction==='W'?'selected':''}>W</option>
        </select>
      </div>
      
      <label>Marker Type:</label>
      <div class="marker-type-grid" id="markerTypeGrid"></div>
      
      <label>Waypoint Info/Notes:</label>
      <textarea id="editInfo" rows="3" placeholder="Enter information about this waypoint..." style="width:100%; padding:6px; margin:5px 0;">${wp.info || ''}</textarea>
      
      <div style="margin-top:15px;">
        <button class="btn" id="saveEdit" style="background:#28a745;">Save</button>
        <button class="btn" id="cancelEdit" style="background:#dc3545;">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(editModal);
  
  const grid = editModal.querySelector('#markerTypeGrid');
  Object.keys(MARKER_TYPES).forEach(typeKey => {
    const type = MARKER_TYPES[typeKey];
    const option = document.createElement('div');
    option.className = 'marker-type-option' + (wp.markerType === typeKey ? ' selected' : '');
    option.dataset.type = typeKey;
    
    let iconPreview = '';
    if(type.shape === 'H') iconPreview = '<div style="width:16px;height:16px;background:'+type.color+';border:1.5px solid #000;display:inline-flex;align-items:center;justify-content:center;font-weight:bold;color:#fff;font-size:11px;">H</div>';
    else if(type.shape === 'star') iconPreview = '<span style="color:'+type.color+';font-size:16px;">‚òÖ</span>';
    else if(type.shape === 'diamond') iconPreview = '<span style="color:'+type.color+';font-size:16px;">‚óÜ</span>';
    else if(type.shape === 'triangle') iconPreview = '<span style="color:'+type.color+';font-size:16px;">‚ñ≤</span>';
    else if(type.shape === 'square') iconPreview = '<span style="color:'+type.color+';font-size:16px;">‚ñ†</span>';
    else iconPreview = '<span style="color:'+type.color+';font-size:16px;">‚óè</span>';
    
    option.innerHTML = `<div class="marker-icon-preview">${iconPreview}</div><div class="marker-type-label">${type.label}</div>`;
    option.onclick = function(){
      editModal.querySelectorAll('.marker-type-option').forEach(o => o.classList.remove('selected'));
      this.classList.add('selected');
    };
    grid.appendChild(option);
  });
  
  editModal.querySelector('#saveEdit').onclick = () => {
    const newName = editModal.querySelector('#editName').value.trim();
    const latDeg = parseFloat(editModal.querySelector('#editLatDeg').value);
    const latMin = parseFloat(editModal.querySelector('#editLatMin').value);
    const latDir = editModal.querySelector('#editLatDir').value;
    const lonDeg = parseFloat(editModal.querySelector('#editLonDeg').value);
    const lonMin = parseFloat(editModal.querySelector('#editLonMin').value);
    const lonDir = editModal.querySelector('#editLonDir').value;
    const selectedType = editModal.querySelector('.marker-type-option.selected')?.dataset.type || 'default';
    const newInfo = editModal.querySelector('#editInfo').value.trim();
    
    if(newName) wp.name = newName;
    if(!isNaN(latDeg) && !isNaN(latMin)){
      wp.lat = DMSToDecimal(latDeg, latMin, latDir);
    }
    if(!isNaN(lonDeg) && !isNaN(lonMin)){
      wp.lon = DMSToDecimal(lonDeg, lonMin, lonDir);
    }
    wp.markerType = selectedType;
    wp.info = newInfo;
    
    map.removeLayer(markers[id]);
    const newMarker = createMarkerForWaypoint(wp);
    markers[id] = newMarker;
    
    renderList();
    saveLocal();
    document.body.removeChild(editModal);
  };
  
  editModal.querySelector('#cancelEdit').onclick = () => {
    document.body.removeChild(editModal);
  };
};

function createMarkerForWaypoint(wp){
  const markerType = MARKER_TYPES[wp.markerType || 'default'];
  let marker;
  
  if(markerType.shape === 'circle'){
    marker = L.circleMarker([wp.lat, wp.lon], {
      radius: 5,
      color: markerType.color,
      fillColor: markerType.color,
      fillOpacity: 0.9,
      weight: 2
    }).addTo(map);
  } else {
    marker = L.marker([wp.lat, wp.lon], {
      icon: createMarkerIcon(wp.markerType || 'default')
    }).addTo(map);
  }
  
  const popupContent = `<b>${wp.name}</b><br>${formatDMS(wp.lat, true)}, ${formatDMS(wp.lon, false)}<br>${markerType.label}${wp.info ? '<br><i>' + wp.info + '</i>' : ''}<br><a href="#" onclick="editWaypoint(${wp.id})">Edit</a>`;
  marker.bindPopup(popupContent);
  marker.on('click', () => window.selectWaypoint(wp.id));
  
  return marker;
}

window.deleteWaypoint = function(id){
  if(!confirm('Delete this waypoint?'))return;
  waypoints=waypoints.filter(w=>w.id!==id);
  map.removeLayer(markers[id]); delete markers[id];
  renderList(); saveLocal();
};

window.selectWaypoint = function(id){
  const idx=selected.indexOf(id);
  if(idx===-1) selected.push(id); else selected.splice(idx,1);
  
  waypoints.forEach(wp => {
    const marker = markers[wp.id];
    if(!marker) return;
    
    const isSelected = selected.includes(wp.id);
    const markerType = MARKER_TYPES[wp.markerType || 'default'];
    
    if(marker instanceof L.CircleMarker){
      marker.setStyle({
        color: isSelected ? '#00f' : markerType.color,
        fillColor: isSelected ? '#00f' : markerType.color
      });
    }
  });
};

function addWaypoint(lat,lon,name,markerType='default',info=''){
  const id = Date.now()+Math.floor(Math.random()*999);
  const wp={id,lat,lon,name:name||('WP-'+(waypoints.length+1)),markerType,info};
  waypoints.push(wp);
  
  const marker = createMarkerForWaypoint(wp);
  markers[id] = marker;
  
  renderList(); 
  saveLocal();
}

function addWaypointNoSave(lat,lon,name,markerType='default',info=''){
  const id = Date.now()+Math.floor(Math.random()*999);
  const wp={id,lat,lon,name:name||('WP-'+(waypoints.length+1)),markerType,info};
  waypoints.push(wp);
  
  const marker = createMarkerForWaypoint(wp);
  markers[id] = marker;
  
  renderList();
}

function makeRoute(){
  if(selected.length<2){ alert('Select at least 2 waypoints'); return; }
  if(routeLayer) map.removeLayer(routeLayer);
  checkpointMarkers.forEach(cp=>map.removeLayer(cp)); checkpointMarkers=[];
  const latlngs=selected.map(id=>{ const w=waypoints.find(wp=>wp.id===id); return [w.lat,w.lon]; });
  routeLayer=L.polyline(latlngs,{color:'#ff6600',weight:2}).addTo(map);
  updateRouteSummary();
  routeLayer.on('click', e => addCheckpoint(e.latlng));
}

function updateRouteSummary(){
  if(selected.length<2) return;
  let cumulativeDistance=0, cumulativeTimeInput=0, cumulativeTimeGPS=0;
  const speedInput=parseFloat(document.getElementById('speedInput').value)||0;
  routeSummaryDiv.innerHTML='';
  for(let i=0;i<selected.length-1;i++){
    const a=waypoints.find(w=>w.id===selected[i]);
    const b=waypoints.find(w=>w.id===selected[i+1]);
    const dist=haversineNM(a.lat,a.lon,b.lat,b.lon);
    cumulativeDistance+=dist;
    const timeInput=speedInput>0 ? (dist/speedInput*60) : 0;
    const timeGPS=lastSpeedGPS>0 ? (dist/lastSpeedGPS*60) : 0;
    cumulativeTimeInput+=timeInput; cumulativeTimeGPS+=timeGPS;
    const brg=bearing(a.lat,a.lon,b.lat,b.lon);
    routeSummaryDiv.innerHTML+=`<b>${a.name} ‚Üí ${b.name}</b>: ${dist.toFixed(2)} NM, ${brg.toFixed(1)}¬∞, ETA Input: ${timeInput.toFixed(1)} min, ETA GPS: ${timeGPS.toFixed(1)} min<br>`;
  }
  routeSummaryDiv.innerHTML+=`<b>Total:</b> ${cumulativeDistance.toFixed(2)} NM, ETA Input: ${cumulativeTimeInput.toFixed(1)} min, ETA GPS: ${cumulativeTimeGPS.toFixed(1)} min`;
}

function addCheckpoint(latlng){
  let prevLatLng;
  if(checkpointMarkers.length>0){
    prevLatLng = checkpointMarkers[checkpointMarkers.length-1].getLatLng();
  } else if(selected.length>0){
    const firstWp = waypoints.find(w => w.id===selected[0]);
    prevLatLng = {lat:firstWp.lat, lng:firstWp.lon};
  } else if(flyMarker){
    prevLatLng = flyMarker.getLatLng();
  } else {
    prevLatLng = map.getCenter();
  }
  const dist = haversineNM(prevLatLng.lat, prevLatLng.lng, latlng.lat, latlng.lng);
  const inputSpeed = parseFloat(document.getElementById('speedInput').value) || 0;
  const etaInput = inputSpeed>0 ? (dist/inputSpeed*60).toFixed(1)+' min' : 'N/A';
  const etaGPS  = lastSpeedGPS>0 ? (dist/lastSpeedGPS*60).toFixed(1)+' min' : 'N/A';
  const cpMarker = L.circleMarker([latlng.lat, latlng.lng], { radius:4, color:'#0a0', fillColor:'#0a0', fillOpacity:0.8 }).addTo(map);
  cpMarker.bindPopup(`Checkpoint<br>Distance: ${dist.toFixed(2)} NM<br>ETA Input: ${etaInput}<br>ETA GPS: ${etaGPS}`).openPopup();
  cpMarker.bindTooltip(`Dist: ${dist.toFixed(2)} NM, ETA Input: ${etaInput}, ETA GPS: ${etaGPS}`, {permanent:true,direction:'top'});
  checkpointMarkers.push(cpMarker);
}

function clearRoute(){
  if(routeLayer) map.removeLayer(routeLayer);
  routeLayer=null;
  checkpointMarkers.forEach(cp=>map.removeLayer(cp)); checkpointMarkers=[];
  selected=[]; routeSummaryDiv.innerHTML='';
  waypoints.forEach(wp => {
    const marker = markers[wp.id];
    if(!marker) return;
    const markerType = MARKER_TYPES[wp.markerType || 'default'];
    if(marker instanceof L.CircleMarker){
      marker.setStyle({color: markerType.color, fillColor: markerType.color});
    }
  });
}

function renderAreaList(){
  areaListDiv.innerHTML='';
  editAreaSelect.innerHTML='<option value="">Select Area to Edit</option>';
  deleteAreaSelect.innerHTML='<option value="">Select Area to Delete</option>';
  
  areas.forEach(area=>{
    const div=document.createElement('div');
    div.className='area-item';
    div.style.borderLeft = `4px solid ${area.color || '#8b45c1'}`;
    div.innerHTML=`<b>${area.name}</b> <span style="color:${area.color || '#8b45c1'};">‚óè</span><br><span class="small">${area.corners.length} corners</span>${area.info ? `<div class="info-text">${area.info}</div>` : ''}`;
    areaListDiv.appendChild(div);
    
    const editOpt=document.createElement('option');
    editOpt.value=area.id; editOpt.text=area.name; 
    editAreaSelect.appendChild(editOpt);
    
    const delOpt=document.createElement('option');
    delOpt.value=area.id; delOpt.text=area.name; 
    deleteAreaSelect.appendChild(delOpt);
  });
}

function drawArea(area){
  if(areaPolygons[area.id]) map.removeLayer(areaPolygons[area.id]);
  
  const latlngs = area.corners.map(c => [c.lat, c.lon]);
  const areaColor = area.color || '#8b45c1';
  const polygon = L.polygon(latlngs, {
    color: areaColor,
    fillColor: areaColor,
    fillOpacity: 0.2,
    weight: 2
  }).addTo(map);
  
  polygon.bindTooltip(area.name, {
    permanent: true,
    direction: 'center',
    className: 'area-label',
    opacity: 0.8
  });
  
  areaPolygons[area.id] = polygon;
}

function showAreaModal(editMode = false, areaId = null){
  const modal = document.getElementById('areaModal');
  const modalTitle = document.getElementById('modalTitle');
  const numCornersInput = document.getElementById('numCorners');
  const cornerInputsDiv = document.getElementById('cornerInputs');
  const nameSection = document.getElementById('nameSection');
  const areaNameInput = document.getElementById('areaName');
  const areaInfoInput = document.getElementById('areaInfo');
  
  modal.style.display = 'block';
  cornerInputsDiv.innerHTML = '';
  nameSection.style.display = 'none';
  
  // Reset color selector
  document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
  
  if(editMode && areaId){
    editingAreaId = areaId;
    const area = areas.find(a => a.id === areaId);
    if(!area) return;
    
    modalTitle.textContent = 'Edit Area';
    numCornersInput.value = area.corners.length;
    areaNameInput.value = area.name;
    areaInfoInput.value = area.info || '';
    
    // Set selected color
    const selectedColor = area.color || '#dc3545';
    document.querySelectorAll('.color-option').forEach(opt => {
      if(opt.dataset.color === selectedColor){
        opt.classList.add('selected');
      }
    });
    
    createCornerInputs(area.corners.length, area.corners);
  } else {
    editingAreaId = null;
    modalTitle.textContent = 'Create New Area';
    numCornersInput.value = '';
    areaNameInput.value = '';
    areaInfoInput.value = '';
    // Select default color (red)
    document.querySelector('.color-option[data-color="#dc3545"]').classList.add('selected');
  }
}

// Color selector click handlers
document.querySelectorAll('.color-option').forEach(option => {
  option.onclick = function(){
    document.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
    this.classList.add('selected');
  };
});

function createCornerInputs(numCorners, existingCorners = []){
  const cornerInputsDiv = document.getElementById('cornerInputs');
  const nameSection = document.getElementById('nameSection');
  cornerInputsDiv.innerHTML = '';
  
  for(let i = 0; i < numCorners; i++){
    const corner = existingCorners[i];
    let latDMS = {degrees: '', minutes: '', direction: 'N'};
    let lonDMS = {degrees: '', minutes: '', direction: 'E'};
    
    if(corner){
      latDMS = decimalToDMS(corner.lat, true);
      lonDMS = decimalToDMS(corner.lon, false);
    }
    
    const cornerDiv = document.createElement('div');
    cornerDiv.className = 'corner-input';
    cornerDiv.innerHTML = `
      <label>Corner ${i+1}:</label>
      <div style="display:flex; gap:3px; margin:3px 0;">
        <input type="number" id="lat_deg_${i}" placeholder="Lat ¬∞" value="${corner ? latDMS.degrees : ''}" style="flex:1; padding:4px; font-size:12px;">
        <input type="number" step="0.001" id="lat_min_${i}" placeholder="'" value="${corner ? latDMS.minutes.toFixed(3) : ''}" style="flex:1; padding:4px; font-size:12px;">
        <select id="lat_dir_${i}" style="flex:0.5; padding:4px; font-size:12px;">
          <option value="N" ${latDMS.direction==='N'?'selected':''}>N</option>
          <option value="S" ${latDMS.direction==='S'?'selected':''}>S</option>
        </select>
      </div>
      <div style="display:flex; gap:3px; margin:3px 0;">
        <input type="number" id="lon_deg_${i}" placeholder="Lon ¬∞" value="${corner ? lonDMS.degrees : ''}" style="flex:1; padding:4px; font-size:12px;">
        <input type="number" step="0.001" id="lon_min_${i}" placeholder="'" value="${corner ? lonDMS.minutes.toFixed(3) : ''}" style="flex:1; padding:4px; font-size:12px;">
        <select id="lon_dir_${i}" style="flex:0.5; padding:4px; font-size:12px;">
          <option value="E" ${lonDMS.direction==='E'?'selected':''}>E</option>
          <option value="W" ${lonDMS.direction==='W'?'selected':''}>W</option>
        </select>
      </div>
    `;
    cornerInputsDiv.appendChild(cornerDiv);
  }
  
  nameSection.style.display = 'block';
}

function saveArea(){
  const numCorners = parseInt(document.getElementById('numCorners').value);
  const areaName = document.getElementById('areaName').value.trim();
  const areaInfo = document.getElementById('areaInfo').value.trim();
  const selectedColorOption = document.querySelector('.color-option.selected');
  const areaColor = selectedColorOption ? selectedColorOption.dataset.color : '#dc3545';
  
  if(!areaName){
    alert('Please enter an area name');
    return;
  }
  
  const corners = [];
  for(let i = 0; i < numCorners; i++){
    const latDeg = parseFloat(document.getElementById(`lat_deg_${i}`).value);
    const latMin = parseFloat(document.getElementById(`lat_min_${i}`).value);
    const latDir = document.getElementById(`lat_dir_${i}`).value;
    const lonDeg = parseFloat(document.getElementById(`lon_deg_${i}`).value);
    const lonMin = parseFloat(document.getElementById(`lon_min_${i}`).value);
    const lonDir = document.getElementById(`lon_dir_${i}`).value;
    
    if(isNaN(latDeg) || isNaN(latMin) || isNaN(lonDeg) || isNaN(lonMin)){
      alert(`Invalid coordinates for corner ${i+1}`);
      return;
    }
    
    const lat = DMSToDecimal(latDeg, latMin, latDir);
    const lon = DMSToDecimal(lonDeg, lonMin, lonDir);
    corners.push({lat, lon});
  }
  
  if(editingAreaId){
    const area = areas.find(a => a.id === editingAreaId);
    if(area){
      area.name = areaName;
      area.corners = corners;
      area.color = areaColor;
      area.info = areaInfo;
      drawArea(area);
    }
  } else {
    const id = Date.now() + Math.floor(Math.random()*999);
    const newArea = {id, name: areaName, corners, color: areaColor, info: areaInfo};
    areas.push(newArea);
    drawArea(newArea);
  }
  
  renderAreaList();
  saveLocal();
  closeAreaModal();
}

function closeAreaModal(){
  document.getElementById('areaModal').style.display = 'none';
  editingAreaId = null;
}

function deleteArea(areaId){
  if(!confirm('Delete this area?')) return;
  
  areas = areas.filter(a => a.id !== areaId);
  if(areaPolygons[areaId]){
    map.removeLayer(areaPolygons[areaId]);
    delete areaPolygons[areaId];
  }
  
  renderAreaList();
  saveLocal();
}

async function ensureGeolocationPermission(){
  if(!('geolocation' in navigator)) { alert('Geolocation not supported'); return false; }
  if(navigator.permissions && navigator.permissions.query){
    try{
      const status = await navigator.permissions.query({ name: 'geolocation' });
      if(status.state === 'granted') return true;
      if(status.state === 'prompt'){
        return new Promise((res) => {
          navigator.geolocation.getCurrentPosition(
            ()=>res(true),
            ()=>res(false),
            { enableHighAccuracy:true, maximumAge:1000, timeout:10000 }
          );
        });
      }
      alert('Location permission is denied. Enable location for this site in your browser settings.');
      return false;
    } catch(e){}
  }
  return new Promise((res)=>{
    navigator.geolocation.getCurrentPosition(
      ()=>res(true),
      ()=>res(false),
      { enableHighAccuracy:true, maximumAge:1000, timeout:10000 }
    );
  });
}

function startFlying(){
  if(flyMarker) return alert('Already flying');
  const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if(!(location.protocol === 'https:' || isLocalhost)){
    alert('Geolocation needs HTTPS or localhost. Use your GitHub Pages link.');
    return;
  }
  ensureGeolocationPermission().then(ok=>{
    if(!ok) return;
    gpsInfoDiv.style.display = 'block';
    flyMarker=L.circleMarker([0,0],{radius:6,color:'#a52a2a',fillColor:'#a52a2a',fillOpacity:0.9}).addTo(map);
    flyWatchId=navigator.geolocation.watchPosition(pos=>{
      const lat=pos.coords.latitude, lon=pos.coords.longitude;
      const speed=(pos.coords.speed || 0) * 1.94384;
      const heading=pos.coords.heading !== null && pos.coords.heading !== undefined ? pos.coords.heading : lastCourseGPS;
      
      updateGPSInfo(speed, heading);
      
      flyMarker.setLatLng([lat,lon]);
      coordsOut.textContent = formatDMS(lat, true) + ', ' + formatDMS(lon, false);
      map.setView([lat,lon]);
      updateRouteSummary();
      
      // Update moving track if active
      if (movingTrackActive) {
        updateMovingTrack();
      }
    },err=>{
      alert('Error getting location: '+(err.message||err.code));
    },{enableHighAccuracy:true,maximumAge:1000});
  });
}

function stopFlying(){
  if(flyWatchId) navigator.geolocation.clearWatch(flyWatchId);
  if(flyMarker) map.removeLayer(flyMarker);
  flyMarker=null; flyWatchId=null;
  gpsInfoDiv.style.display = 'none';
  
  // Also stop moving track when flying stops
  if (movingTrackActive) {
    stopMovingTrack();
  }
}

function startDirectTo(){
  if(!directSelect.value) return alert('Select waypoint first');
  directTargetId=parseInt(directSelect.value);
  const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if(!(location.protocol === 'https:' || isLocalhost)){
    alert('Geolocation needs HTTPS or localhost. Use your GitHub Pages link.');
    return;
  }
  ensureGeolocationPermission().then(ok=>{
    if(!ok) return;
    gpsInfoDiv.style.display = 'block';
    if(directLayer) map.removeLayer(directLayer);
    directLayer=L.polyline([],{color:'#ff00ff',weight:2,dashArray:'4'}).addTo(map);
    if(!flyMarker) flyMarker=L.circleMarker([0,0],{radius:6,color:'#a52a2a',fillColor:'#a52a2a',fillOpacity:0.9}).addTo(map);
    flyWatchId=navigator.geolocation.watchPosition(pos=>{
      const lat=pos.coords.latitude, lon=pos.coords.longitude;
      const speed=(pos.coords.speed || 0) * 1.94384;
      const heading=pos.coords.heading !== null && pos.coords.heading !== undefined ? pos.coords.heading : lastCourseGPS;
      
      updateGPSInfo(speed, heading);
      
      flyMarker.setLatLng([lat,lon]);
      coordsOut.textContent = formatDMS(lat, true) + ', ' + formatDMS(lon, false);
      map.setView([lat,lon]);
      const target=waypoints.find(w=>w.id===directTargetId);
      if(!target) return;
      const dist=haversineNM(lat,lon,target.lat,target.lon);
      const inputSpeed=parseFloat(document.getElementById('speedInput').value)||0;
      const etaInput=inputSpeed>0 ? (dist/inputSpeed*60).toFixed(1)+' min':'N/A';
      const etaGPS = lastSpeedGPS>0 ? (dist/lastSpeedGPS*60).toFixed(1)+' min' : 'N/A';
      const brg=bearing(lat,lon,target.lat,target.lon);
      routeSummaryDiv.innerHTML=`Direct-To ${target.name}<br>Distance: ${dist.toFixed(2)} NM<br>Bearing: ${brg.toFixed(1)}¬∞<br>ETA Input: ${etaInput}<br>ETA GPS: ${etaGPS}`;
      directLayer.setLatLngs([[lat,lon],[target.lat,target.lon]]);
      
      // Update moving track if active
      if (movingTrackActive) {
        updateMovingTrack();
      }
    },err=>{
      alert('Error getting location: '+(err.message||err.code));
    },{enableHighAccuracy:true,maximumAge:1000});
  });
}

function stopDirectTo(){
  if(flyWatchId) navigator.geolocation.clearWatch(flyWatchId);
  if(directLayer) map.removeLayer(directLayer);
  directLayer=null; directTargetId=null;
  routeSummaryDiv.innerHTML='';
  if(flyMarker) { map.removeLayer(flyMarker); flyMarker=null; }
  flyWatchId=null;
  gpsInfoDiv.style.display = 'none';
  
  // Also stop moving track when direct-to stops
  if (movingTrackActive) {
    stopMovingTrack();
  }
}

recenterBtn.onclick = ()=>{
  if(flyMarker){ map.setView(flyMarker.getLatLng()); }
  else { alert('Flying or Direct-To mode not active'); }
};

function saveLocal(){ 
  try {
    localStorage.setItem('map_waypoints_v6',JSON.stringify(waypoints));
    localStorage.setItem('map_areas_v2',JSON.stringify(areas));
    console.log('Saved successfully - Waypoints:', waypoints.length, 'Areas:', areas.length);
  } catch(e) {
    console.error('Save error:', e);
    alert('Error saving data: ' + e.message);
  }
}

function loadLocal(){
  // Load waypoints
  const data=localStorage.getItem('map_waypoints_v6');
  if(data){
    try{ 
      const arr=JSON.parse(data); 
      arr.forEach(w=>addWaypointNoSave(w.lat,w.lon,w.name,w.markerType||'default',w.info||'')); 
      console.log('Loaded waypoints:', arr.length);
    }
    catch(e){ console.error('Error loading waypoints:', e); }
  }
  
  // Load areas
  const areaData=localStorage.getItem('map_areas_v2');
  if(areaData){
    try{ 
      const loadedAreas = JSON.parse(areaData);
      console.log('Raw area data from localStorage:', loadedAreas);
      
      loadedAreas.forEach(area=>{
        // Ensure color and info exists for old data
        if(!area.color) area.color = '#8b45c1';
        if(!area.info) area.info = '';
        
        // Add to areas array
        areas.push(area);
        
        // Draw on map
        drawArea(area);
      });
      
      renderAreaList();
      console.log('Loaded areas successfully:', areas.length);
    }
    catch(e){ 
      console.error('Error loading areas:', e); 
      alert('Error loading areas: ' + e.message);
    }
  } else {
    console.log('No area data found in localStorage');
  }
}

document.getElementById('goBtn').onclick=()=>{
  const latDeg = parseFloat(document.getElementById('latDeg').value);
  const latMin = parseFloat(document.getElementById('latMin').value);
  const latDir = document.getElementById('latDir').value;
  const lonDeg = parseFloat(document.getElementById('lonDeg').value);
  const lonMin = parseFloat(document.getElementById('lonMin').value);
  const lonDir = document.getElementById('lonDir').value;
  
  if(isNaN(latDeg) || isNaN(latMin) || isNaN(lonDeg) || isNaN(lonMin)){
    alert('Invalid coordinates');
    return;
  }
  
  const lat = DMSToDecimal(latDeg, latMin, latDir);
  const lon = DMSToDecimal(lonDeg, lonMin, lonDir);
  
  map.setView([lat, lon], Math.max(map.getZoom(), 12));
  addWaypoint(lat, lon, 'Manual');
};

document.getElementById('routeBtn').onclick=makeRoute;
document.getElementById('clearRouteBtn').onclick=clearRoute;
document.getElementById('saveBtn').onclick=()=>{ saveLocal(); alert('Saved waypoints and areas!'); };
document.getElementById('exportBtn').onclick=()=>{
  const exportData = {waypoints, areas};
  const blob=new Blob([JSON.stringify(exportData,null,2)],{type:'application/json'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='waypoints_areas.json'; a.click();
};
document.getElementById('importBtn').onclick=()=>{
  try{ 
    const importData=JSON.parse(document.getElementById('jsonArea').value);
    if(importData.waypoints){
      importData.waypoints.forEach(w=>addWaypoint(w.lat,w.lon,w.name,w.markerType||'default',w.info||''));
    }
    if(importData.areas){
      importData.areas.forEach(area=>{
        if(!area.color) area.color = '#8b45c1';
        if(!area.info) area.info = '';
        // Make sure it has a unique ID
        if(!area.id) area.id = Date.now() + Math.floor(Math.random()*999);
        areas.push(area);
        drawArea(area);
      });
      renderAreaList();
    }
    saveLocal();
    alert('Imported successfully');
  }
  catch(e){alert('Invalid JSON: ' + e.message);}
};
document.getElementById('startFlyBtn').onclick=startFlying;
document.getElementById('stopFlyBtn').onclick=stopFlying;
document.getElementById('startDirectBtn').onclick=startDirectTo;
document.getElementById('stopDirectBtn').onclick=stopDirectTo;

document.getElementById('createAreaBtn').onclick=()=>showAreaModal(false);
document.getElementById('setCornerBtn').onclick=()=>{
  const numCorners = parseInt(document.getElementById('numCorners').value);
  if(isNaN(numCorners) || numCorners < 3){
    alert('Please enter at least 3 corners');
    return;
  }
  createCornerInputs(numCorners);
};
document.getElementById('saveAreaBtn').onclick=saveArea;
document.getElementById('cancelAreaBtn').onclick=closeAreaModal;
document.getElementById('editAreaBtn').onclick=()=>{
  const areaId = parseInt(editAreaSelect.value);
  if(!areaId){
    alert('Please select an area to edit');
    return;
  }
  showAreaModal(true, areaId);
};
document.getElementById('deleteAreaBtn').onclick=()=>{
  const areaId = parseInt(deleteAreaSelect.value);
  if(!areaId){
    alert('Please select an area to delete');
    return;
  }
  deleteArea(areaId);
};

loadLocal();

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js')
      .then(reg => console.log('SW registered', reg.scope))
      .catch(err => console.error('SW registration failed', err));
  });
}

}

checkAuthentication();
</script>
</body>
</html>
